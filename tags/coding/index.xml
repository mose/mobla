<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on Moselog</title>
    <link>http://localhost:1313/tags/coding/</link>
    <description>Recent content in Coding on Moselog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 31 Aug 2015 12:10:31 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/coding/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Greenruby 134</title>
      <link>http://localhost:1313/2015/08/31/greenruby-134</link>
      <pubDate>Mon, 31 Aug 2015 12:10:31 +0800</pubDate>
      
      <guid>http://localhost:1313/2015/08/31/greenruby-134</guid>
      <description>

&lt;h2 id=&#34;the-dimensions-of-coding:b983cb306bd4bcf38c9b84ac40779659&#34;&gt;The dimensions of coding&lt;/h2&gt;

&lt;p&gt;Today while wandering around in my weekly hunt for good links, my eye has been
attracted by a post named &lt;a href=&#34;https://medium.com/@scosta/coding-is-three-dimensional-cb331d1b4ad8&#34;&gt;Coding is three dimensional&lt;/a&gt;. It&amp;rsquo;s quite an
interesting way to consider it. But the reason why it struck me is that it was
missing the fourth dimension. That makes all the difference when you get years
of coding. You know that time is a parameter.&lt;/p&gt;

&lt;p&gt;Code don&amp;rsquo;t exist out of time. It has a past, perspective of a future, that
both shape its current morphology. There are a lot of efforts to produce code
analysis. But the real analyst is an historian and needs a systemic approach
that includes time as a factor. We are still far from being able to automate
that. In some ways, it&amp;rsquo;s a good news, we won&amp;rsquo;t be replaced by small scripts
very soon.&lt;/p&gt;

&lt;p&gt;The time factor is actually the essential element in the &lt;a href=&#34;http://martinfowler.com/bliki/TechnicalDebt.html&#34;&gt;technical debt&lt;/a&gt;
formula. Purist coders can&amp;rsquo;t cope with technical debt but if you have two
onces of business man inside, it makes total sense. The tradeoff in technical
quality versus fast deliverability only makes sense because the timing is
critical. &lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/a-mess-is-not-a-technical-debt&#34;&gt;A mess is not a technical debt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If coding was disconnected from the market, and if it was not a business or
more like an art, maybe time would not be that critical. But even open source
software is dependent on the market at one point or another. I fail to see how
it could be different.&lt;/p&gt;

&lt;p&gt;Honestly, I would prefer clean coding and no market tradeoff, but that&amp;rsquo;s just
a dream.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Greenruby 127</title>
      <link>http://localhost:1313/2015/07/12/greenruby-127</link>
      <pubDate>Sun, 12 Jul 2015 12:10:31 +0800</pubDate>
      
      <guid>http://localhost:1313/2015/07/12/greenruby-127</guid>
      <description>

&lt;h2 id=&#34;javascript-and-thoughts-on-programming:5d8b105fb300dee4745f73b31fcdff54&#34;&gt;Javascript and thoughts on programming&lt;/h2&gt;

&lt;p&gt;Recently I&amp;rsquo;ve been playing with Hubot plugins code in coffeescript for our
company. That&amp;rsquo;s a while I didn&amp;rsquo;t do much js but I used it for a long time and
I didn&amp;rsquo;t find it too difficult to catch up. But for some reason, it brought me
the same feeling I have each time I get back to that language. I feel dirty.
Still I can do what I need to do, for sure, but I don&amp;rsquo;t feel like a builder,
more like an acrobat. And I&amp;rsquo;m far from a purist.&lt;/p&gt;

&lt;p&gt;Some people talk about javascript taking over the world. But that language
imho just was there at the right place at the right time. By having a runtime
embedded in browsers and browsers libraries, it has been used to hijack the
most used software on our computers and mobile devices, to transform them into
richer clients. Along the way various layers were added to fulfill the need of
software design, because javascript initial goal was merely DOM manipulation.&lt;/p&gt;

&lt;p&gt;The thing that always stroke me the most with javascript is that despite the
efforts from ecmascript, it has no formal standard or documentation. It is
pretty extensively documented, of course, but because the language is pushed
forward by the implementations rather than from a standard body, it gets a bit
messy.&lt;/p&gt;

&lt;p&gt;I saw a &lt;a href=&#34;http://cube-drone.com/comics/c/relentless-persistence&#34;&gt;drawing&lt;/a&gt; this week that illustrates the mess quite well. It feels
like Javascript is waiting for something to come replace it.&lt;/p&gt;

&lt;p&gt;But there is hope with ES6. Seems like in recent years the normative effort on
the ecmascript standard got some more traction and some more press coverage.
But I personally don&amp;rsquo;t think it&amp;rsquo;s going to bring the solution. I enjoyed
reading the &lt;a href=&#34;http://www.sitepoint.com/future-programming-webassembly-life-after-javascript/&#34;&gt;thoughts of Eric Elliot&lt;/a&gt; on that topic but I&amp;rsquo;m not sure
he&amp;rsquo;s right on everything. But what he&amp;rsquo;s right about, is that there will be an
after-javascript.&lt;/p&gt;

&lt;p&gt;Unless that after javascript doesn&amp;rsquo;t arrive fast enough and gets useless by
some new programming paradigm that may appear one day soon. I mean, in the
next 10 years. At some point, like big data is too complex to be handled by
human, programming will also get too complex and will be handled by
algorithms. We already &lt;a href=&#34;http://phys.org/news/2015-07-code-faster-expert.html&#34;&gt;see it coming&lt;/a&gt;. And all programmers will then
become high end workflow designers or just play with antiquities.&lt;/p&gt;

&lt;p&gt;In this perspective, I think javascript is a great intermediary technology for
the time being, given its pervasive aspect. It&amp;rsquo;s far from satisfying, but it
does the job. But the younger generation should keep an eye on higher level
abstract approaches, like systems architectures, workflow logics, organization
patterns, because imho that will drive software design in the next 10-20
years.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Greenruby 124</title>
      <link>http://localhost:1313/2015/06/21/greenruby-124</link>
      <pubDate>Sun, 21 Jun 2015 12:10:31 +0800</pubDate>
      
      <guid>http://localhost:1313/2015/06/21/greenruby-124</guid>
      <description>

&lt;h2 id=&#34;the-yin-and-yang-of-software-development:aff213456bcfa77c48418a9edd40a18a&#34;&gt;The yin and yang of software development&lt;/h2&gt;

&lt;p&gt;The topic I talked about last week led me to think about it more widely. And I
ended up with the thinking that many problems in software companies are a
clear problem of balance between their yin and their yang.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;https://en.wikipedia.org/wiki/Yin_and_yang&#34;&gt;old chinese principle&lt;/a&gt; is documented in a very old-fashioned
way, opposing genders and principles. But actually it sums up in the fact that
many dynamics are to be based in a balance between two opposing principles.
Otherwise they fail.&lt;/p&gt;

&lt;p&gt;The way I see it, software developers are a nurturing kind. This profile has
to consider long term. It decides actions for later outcomes. It&amp;rsquo;s about
giving life and growing it. It feels closer to the Yin principle.&lt;/p&gt;

&lt;p&gt;On another hand, the business people are bound to a shorter time frame. And I
don&amp;rsquo;t talk about the entrepreneurs and the rare visionary people, but the real
business work force. They are competitive, aggressive, fighters. That really
feels to me like the Yang concept.&lt;/p&gt;

&lt;p&gt;And all occurrences where I saw software companies failing, I think it was
because there was a lack of balance between those 2 principles. Either the
management was too soft and not aggressive enough towards its market, either
it was too aggressive and nurturing was not considered enough in their
equation.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think that this balance requirement applies to everything, to be
honest. But in a constituted body of a software organization, considering the
current (questionable) market economy, it feels that the Yin and the Yang have
to be in balance to grant a chance of survival to the organization.&lt;/p&gt;

&lt;p&gt;One may have the feeling that the dominant Yang (business side) is the more
common case. But they are just more noisy. Many projects stay silently in the
darkness just because there was no real business consideration (or even
refusal of it).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://modeling-languages.com/grady-booch-on-the-future-of-software-engineering-video-and-highlights/&#34;&gt;keynote of Grady Booch&lt;/a&gt; (linked in the video section) confirmed
me in various ways in this opinion. Engineers have the duty to fight for the
balance when they can. They have to understand that it&amp;rsquo;s not a one-way deal,
as well. If you want to exercise programming in a nurturing-only context, win
a lottery and dedicate your time writing free software (where market
requirements don&amp;rsquo;t apply). But in the usual case, you may have to consider if
you are in a balanced context, and if not, try to work on balancing it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>