<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chef on Mose Bla</title>
    <link>http://localhost:1313/mobla/tags/chef/</link>
    <description>Recent content in Chef on Mose Bla</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Jun 2014 09:10:31 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/mobla/tags/chef/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Knife remote command</title>
      <link>http://localhost:1313/mobla/2014/06/26/knife-remote-command</link>
      <pubDate>Thu, 26 Jun 2014 09:10:31 +0800</pubDate>
      
      <guid>http://localhost:1313/mobla/2014/06/26/knife-remote-command</guid>
      <description>&lt;p&gt;Recently we switched from chef-solo to a chef-server setup on our infrastructure, a good occasion to refactor our recipes to better practices. I spent some time figuring out how to replace the &lt;code&gt;fabric&lt;/code&gt; scripts I had for remote execution of actions on various servers, by using a knife plugin. That way I can just use knife abilities and don&amp;rsquo;t need fabric anymore.&lt;/p&gt;

&lt;p&gt;So I created a new file in &lt;code&gt;.chef/plugins/knife/&lt;/code&gt; named &lt;code&gt;apt.rb&lt;/code&gt; for a test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;chef/knife&#39;

module KnifeOpenvpn
  class Apt &amp;lt; Chef::Knife

    banner &amp;quot;knife apt &amp;lt;update|upgrade|simulate&amp;gt; &amp;lt;nodename&amp;gt;&amp;quot;

    deps do
      require &#39;chef/knife/ssh&#39;
      require &#39;chef/node&#39;
      Chef::Knife::Ssh.load_deps
    end

    def run
      if name_args.size == 2
        command_arg = name_args.shift
        server = name_args.shift
      else
        ui.fatal &amp;quot;Syntax: knife apt &amp;lt;update|upgrade|simulate&amp;gt; &amp;lt;nodename&amp;gt;&amp;quot;
        ui.fatal &amp;quot;Where &amp;lt;nodename&amp;gt; is a node name.&amp;quot;
        exit 1
      end
      command = case command_arg
                when &#39;update&#39;
                  &#39;update&#39;
                when &#39;upgrade&#39;
                  &#39;-y upgrade&#39;
                when &#39;simulate&#39;
                  &#39;-y -s upgrade&#39;
                end
      knife_ssh(Chef::Node.load(server).ipaddress, &amp;quot;sudo apt-get #{command}&amp;quot;).run
    end

    def knife_ssh(server, command)
      ssh = Chef::Knife::Ssh.new
      ssh.name_args = [ server, command ]
      ssh.config[:ssh_user] = Chef::Config[:knife][:ssh_user]
      ssh.config[:ssh_port] = Chef::Config[:knife][:ssh_port]
      ssh.config[:identity_file] = Chef::Config[:knife][:identity_file]
      ssh.config[:ssh_gateway] = Chef::Config[:knife][:ssh_gateway]
      ssh.config[:manual] = true
      ssh.config[:host_key_verify] = Chef::Config[:knife][:host_key_verify]
      ssh.config[:on_error] = :raise
      ssh
    end

  end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I just run a &lt;code&gt;knife apt simulate my-server&lt;/code&gt; to execute a &lt;code&gt;apt-get -s -y upgrade&lt;/code&gt; on the &lt;code&gt;my-server&lt;/code&gt; client node. Pretty useful. But I guess that&amp;rsquo;s only a beginning, I should extend it to run on various nodes at the same time and maybe inside threads or something like that, to match the &lt;code&gt;fabric&lt;/code&gt; power.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>